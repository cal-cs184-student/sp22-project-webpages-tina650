<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <style>
    body {
      padding: 100px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
    }

    h1,
    h2,
    h3,
    h4 {
      font-family: 'Source Sans Pro', sans-serif;
    }
  </style>
  <title>CS 184 Mesh Editor</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

  <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2022</h1>
  <h1 align="middle">Project 2: Mesh Editor</h1>
  <h2 align="middle">Tina Li & Daniel Won, CS184-aax & CS184-ack</h2>
  <h3 align="middle"><a href="https://cal-cs184-student.github.io/sp22-project-webpages-tina650/proj2/index.html">https://cal-cs184-student.github.io/sp22-project-webpages-tina650/proj2/index.html</a></h3>

  <br><br>

  <div>

    <h2 align="middle">Overview</h2>
    <p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole.
      Share your thoughts on what interesting things you've learned from completing the project.</p>

    <h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

    <h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
    
    <p>
      Casteljauâ€™s algorithm is a recursive way to draw a curve using linear interpolation. When given n control points and the parameter <i>t </i>, we can compute the n - 1 
      intermediate control point at <i>t </i> using linear interpolation. Basically, we run this recursively and will get a point that lies on the Bezier curve at the given 
      <i>t </i> parameter since the trajectory of the curve is dependent on the variable <i>t </i>. To compute this we created a for loop where we iterate through all the points and 
      everytime we do we add a new point to our new point vector2D, the new point is founded by (1 - <i>t </i>) * current point + <i>t </i> * next point. Then we return the 2Dvector 
      of new points.
    </p>

    
    <h5 align="middle">Bezier curve: 6 Original Control Points</h5>

    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="image/6point.PNG" align="middle" width="250px" />
            <figcaption align="middle">Step 0</figcaption>
          </td>
          <td>
            <img src="image/6point_s1.PNG" align="middle" width="250px" />
            <figcaption align="middle">Step 1</figcaption>
          </td>
          <td>
            <img src="image/6point_s2.PNG" align="middle" width="250px" />
            <figcaption align="middle">Step 2</figcaption>
          </td>
        </tr>
        
        <br>
        
        <tr>
          <td>
            <img src="image/6point_s3.PNG" align="middle" width="250px" />
            <figcaption align="middle">Step 3</figcaption>
          </td>
          <td>
            <img src="image/6point_s4.PNG" align="middle" width="250px" />
            <figcaption align="middle">Step 4</figcaption>
          </td>
          <td>
            <img src="image/6point_s5.PNG" align="middle" width="250px" />
            <figcaption align="middle">Final Evaluated Point</figcaption>
          </td>
        </tr>
      </table>
    </div>
    
    <br> <br>
    
    <div style="display:flex;flex-direction:column;align-items:center;">
  <img src="image/new6p.PNG" style="width:375px;align:middle;"/>
      <figcaption align="middle"> Bezier curve: Modified <i>t</i> </figcaption>


    <h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>

      <p>
      Along the Bazier surface it is just a bunch of Bezier curves in a grid formation. So since a 
      Bazier surface is just made up of Bezier curves in order to evaluate the Bezier surfaces we 
      basically ran the Casteljau algorithm twice. First you implantment it on each row where you
      reduce each row to a single point so then we get a vector of all those points and then we for 
      loop through it again and use casteljau to then get a singular point.
      </p>
      
      <div style="display:flex;flex-direction:column;align-items:center;">
  <img src="image/t2_f.PNG" style="width:375px;align:middle;"/>
      <figcaption align="middle"> Teapot with Bezier Surfaces </figcaption>
      


    <h2 align="middle">Section II: Sampling</h2>

    <h3 align="middle">Part 3: Average normals for half-edge meshes</h3>
        
    <p>
      To implement the area-weighted vertex normals we returned an approximate unit normal of the 
      vertex. In order to do that we normalize the area-weighted average of the normals of the 
      neighboring triangles. We implemented this with mainly a while loop and some simple 
      arithmetic. To make sure we did not get duplicate faces in our normals, we used an if 
      statement in the for loop to make sure we only add the twin to our normal count if the 
      FaceCIter was not equal to the HalfedgeIter face. 
    </p>
        
     <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="image/phong.PNG" align="middle" width="250px" />
            <figcaption align="middle">Teapot with Vertex Normals</figcaption>
          </td>
          <td>
            <img src="image/flat.PNG" align="middle" width="250px" />
            <figcaption align="middle">Teapot without Vertex Normals</figcaption>
          </td>
        </tr>
      </table>
    </div>
        


    <h3 align="middle">Part 4: Half-edge flip</h3>

        <p>
          So first thing we did was create 2 HalfedgeIter variables, bc and cd, one for the halfedge 
          of the passed in EdgeIter and another for the twin of that halfedge we just made. Then we check 
          if either of the faces of those variables are on the boundary because if it is we just return a 
          VertexIter. We then set variables to all the original elements- aka the halfedges, faces, and 
          vertices -of the triangle. Then we made variables for all the new elements, all the new halfedges, 
          faces, vertices, and edges. Then we reset some of the pointers to vertices, edges, and faces. 
          Then we reset the pointers for the original halfedges on all the faces. 
        </p>
        
         <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="image/flat.PNG" align="middle" width="250px" />
            <figcaption align="middle">Teapot Before Flips</figcaption>
          </td>
          <td>
            <img src="image/flip.PNG" align="middle" width="250px" />
            <figcaption align="middle">Teapot After Flips</figcaption>
          </td>
        </tr>
      </table>
    </div>

        <p>
          We did not realize that HalfedgeIter already had set pointers and we were trying to set them, 
          so our code did not work since we were setting some pointers that were already set. This is 
          very frustrating to debug. 
        </p>

    <h3 align="middle">Part 5: Half-edge split</h3>
        
        <p>
          Edge splitting was using a lot of similar concepts and implementation styles from edge flipping, 
          but instead with a lot more pointers to manage. Using the visual example of the triangle given, 
          we initially wrote down every mesh element that were in the original mesh as well as all mesh 
          elements created after the split (including additional edges, vertices, halfedges, and faces). 
          Afterwards, the task was mostly reliant on just setting pointers and making sure to assign the 
          correct elements. 
        </p>
        
        <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="image/flat.PNG" align="middle" width="250px" />
            <figcaption align="middle">Teapot Before Splits</figcaption>
          </td>
          <td>
            <img src="image/split.PNG" align="middle" width="250px" />
            <figcaption align="middle">Teapot After Splits</figcaption>
          </td>
        </tr>
      </table>
    </div>
        
     <p>
       For debugging or implementation tricks, we labeled the halfedges according to the abcd triangle 
       image given, where the first letter corresponded to the source vertex and the second letter referred 
       to the vertex that the halfedge was pointing to, which made it easier to visualize and manage 
       pointers and how they related to each other. In the process of implementing this, we ran into 
       multiple crashes, with errors sourced in the setNeighbors function. To figure out the source of 
       the error, we set up a print statement preceding each call to see where it was occurring.
     </p>
        
        <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="image/flat.PNG" align="middle" width="250px" />
            <figcaption align="middle">Teapot Before Flips and Splits</figcaption>
          </td>
          <td>
            <img src="image/fns.PNG" align="middle" width="250px" />
            <figcaption align="middle">Teapot After Flips and Splits</figcaption>
          </td>
        </tr>
      </table>
    </div>


    <h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>



    <h2 align="middle">Section III: Optional Extra Credit</h2>
    <p>If you are not participating in the optional mesh competition, don't worry about this section!</p>

    <h3 align="middle">Part 7: Design your own mesh!</h3>

</body>

</html>
