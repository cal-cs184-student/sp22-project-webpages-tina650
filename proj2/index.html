<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <style>
    body {
      padding: 100px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
    }

    h1,
    h2,
    h3,
    h4 {
      font-family: 'Source Sans Pro', sans-serif;
    }
  </style>
  <title>CS 184 Mesh Editor</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

  <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2022</h1>
  <h1 align="middle">Project 2: Mesh Editor</h1>
  <h2 align="middle">Tina Li & Daniel Won, CS184-aax & CS184-ack</h2>
  <h3 align="middle"><a href="https://cal-cs184-student.github.io/sp22-project-webpages-tina650/proj2/index.html">https://cal-cs184-student.github.io/sp22-project-webpages-tina650/proj2/index.html</a></h3>

  <br><br>

  <div>

    <h2 align="middle">Overview</h2>
    <p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole.
      Share your thoughts on what interesting things you've learned from completing the project.</p>

    <h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

    <h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
    
    <p>
      Casteljauâ€™s algorithm is a recursive way to draw a curve using linear interpolation. When given n control points and the parameter <i>t </i>, we can compute the n - 1 
      intermediate control point at <i>t </i> using linear interpolation. Basically, we run this recursively and will get a point that lies on the Bezier curve at the given 
      <i>t </i> parameter since the trajectory of the curve is dependent on the variable <i>t </i>. To compute this we created a for loop where we iterate through all the points and 
      everytime we do we add a new point to our new point vector2D, the new point is founded by (1 - <i>t </i>) * current point + <i>t </i> * next point. Then we return the 2Dvector 
      of new points.
    </p>

    
    <h5 align="middle">Bezier curve: 6 Original Control Points</h5>

    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="image/6point.PNG" align="middle" width="250px" />
            <figcaption align="middle">Step 0</figcaption>
          </td>
          <td>
            <img src="image/6point_s1.PNG" align="middle" width="250px" />
            <figcaption align="middle">Step 1</figcaption>
          </td>
          <td>
            <img src="image/6point_s2.PNG" align="middle" width="250px" />
            <figcaption align="middle">Step 2</figcaption>
          </td>
        </tr>
        
        <br>
        
        <tr>
          <td>
            <img src="image/6point_s3.PNG" align="middle" width="250px" />
            <figcaption align="middle">Step 3</figcaption>
          </td>
          <td>
            <img src="image/6point_s4.PNG" align="middle" width="250px" />
            <figcaption align="middle">Step 4</figcaption>
          </td>
          <td>
            <img src="image/6point_s5.PNG" align="middle" width="250px" />
            <figcaption align="middle">Final Evaluated Point</figcaption>
          </td>
        </tr>
      </table>
    </div>
    
    <br> <br>
    
    <div style="display:flex;flex-direction:column;align-items:center;">
  <img src="image/new6p.PNG" style="width:375px;align:middle;"/>
      <figcaption align="middle"> Bezier curve: Modified <i>t</i> </figcaption>


    <h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>

      <p>
      Along the Bazier surface it is just a bunch of Bezier curves in a grid formation. So since a 
      Bazier surface is just made up of Bezier curves in order to evaluate the Bezier surfaces we 
      basically ran the Casteljau algorithm twice. First you implantment it on each row where you
      reduce each row to a single point so then we get a vector of all those points and then we for 
      loop through it again and use casteljau to then get a singular point.
      </p>
      
      <div style="display:flex;flex-direction:column;align-items:center;">
  <img src="image/t2_f.PNG" style="width:375px;align:middle;"/>
      <figcaption align="middle"> Teapot with Bezier Surfaces </figcaption>
      


    <h2 align="middle">Section II: Sampling</h2>

    <h3 align="middle">Part 3: Average normals for half-edge meshes</h3>
        
    <p>
      To implement the area-weighted vertex normals we returned an approximate unit normal of the 
      vertex. In order to do that we normalize the area-weighted average of the normals of the 
      neighboring triangles. We implemented this with mainly a while loop and some simple 
      arithmetic. To make sure we did not get duplicate faces in our normals, we used an if 
      statement in the for loop to make sure we only add the twin to our normal count if the 
      FaceCIter was not equal to the HalfedgeIter face. 
    </p>
        
     <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="image/phong.PNG" align="middle" width="250px" />
            <figcaption align="middle">Teapot with Vertex Normals</figcaption>
          </td>
          <td>
            <img src="image/flat.PNG" align="middle" width="250px" />
            <figcaption align="middle">Teapot without Vertex Normals</figcaption>
          </td>
        </tr>
        


    <h3 align="middle">Part 4: Half-edge flip</h3>


    <h3 align="middle">Part 5: Half-edge split</h3>


    <h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>



    <h2 align="middle">Section III: Optional Extra Credit</h2>
    <p>If you are not participating in the optional mesh competition, don't worry about this section!</p>

    <h3 align="middle">Part 7: Design your own mesh!</h3>

</body>

</html>
